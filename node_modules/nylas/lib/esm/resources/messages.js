import { Resource } from './resource.js';
import * as FormData from 'form-data';
import { encodeAttachmentStreams, objKeysToSnakeCase } from '../utils.js';
import { SmartCompose } from './smartCompose.js';
/**
 * Nylas Messages API
 *
 * The Nylas Messages API allows you to list, find, update, delete, schedule, and send messages on user accounts.
 */
export class Messages extends Resource {
    constructor(apiClient) {
        super(apiClient);
        this.smartCompose = new SmartCompose(apiClient);
    }
    /**
     * Return all Messages
     * @return A list of messages
     */
    list({ identifier, queryParams, overrides, }) {
        return super._list({
            queryParams,
            overrides,
            path: `/v3/grants/${identifier}/messages`,
        });
    }
    /**
     * Return a Message
     * @return The message
     */
    find({ identifier, messageId, overrides, queryParams, }) {
        return super._find({
            path: `/v3/grants/${identifier}/messages/${messageId}`,
            overrides,
            queryParams,
        });
    }
    /**
     * Update a Message
     * @return The updated message
     */
    update({ identifier, messageId, requestBody, overrides, }) {
        return super._update({
            path: `/v3/grants/${identifier}/messages/${messageId}`,
            requestBody,
            overrides,
        });
    }
    /**
     * Delete a Message
     * @return The deleted message
     */
    destroy({ identifier, messageId, overrides, }) {
        return super._destroy({
            path: `/v3/grants/${identifier}/messages/${messageId}`,
            overrides,
        });
    }
    /**
     * Send an email
     * @return The sent message
     */
    async send({ identifier, requestBody, overrides, }) {
        const path = `/v3/grants/${identifier}/messages/send`;
        const requestOptions = {
            method: 'POST',
            path,
            overrides,
        };
        // Use form data only if the attachment size is greater than 3mb
        const attachmentSize = requestBody.attachments?.reduce((total, attachment) => {
            return total + (attachment.size || 0);
        }, 0) || 0;
        if (attachmentSize >= Messages.MAXIMUM_JSON_ATTACHMENT_SIZE) {
            requestOptions.form = Messages._buildFormRequest(requestBody);
        }
        else {
            if (requestBody.attachments) {
                const processedAttachments = await encodeAttachmentStreams(requestBody.attachments);
                requestOptions.body = {
                    ...requestBody,
                    attachments: processedAttachments,
                };
            }
            else {
                requestOptions.body = requestBody;
            }
        }
        return this.apiClient.request(requestOptions);
    }
    /**
     * Retrieve your scheduled messages
     * @return A list of scheduled messages
     */
    listScheduledMessages({ identifier, overrides, }) {
        return super._find({
            path: `/v3/grants/${identifier}/messages/schedules`,
            overrides,
        });
    }
    /**
     * Retrieve a scheduled message
     * @return The scheduled message
     */
    findScheduledMessage({ identifier, scheduleId, overrides, }) {
        return super._find({
            path: `/v3/grants/${identifier}/messages/schedules/${scheduleId}`,
            overrides,
        });
    }
    /**
     * Stop a scheduled message
     * @return The confirmation of the stopped scheduled message
     */
    stopScheduledMessage({ identifier, scheduleId, overrides, }) {
        return super._destroy({
            path: `/v3/grants/${identifier}/messages/schedules/${scheduleId}`,
            overrides,
        });
    }
    /**
     * Remove extra information from a list of messages
     * @return The list of cleaned messages
     */
    cleanMessages({ identifier, requestBody, overrides, }) {
        return this.apiClient.request({
            method: 'PUT',
            path: `/v3/grants/${identifier}/messages/clean`,
            body: requestBody,
            overrides,
        });
    }
    static _buildFormRequest(requestBody) {
        let form;
        // FormData imports are funky, cjs needs to use .default, es6 doesn't
        if (typeof FormData.default !== 'undefined') {
            form = new FormData.default();
        }
        else {
            form = new FormData();
        }
        // Split out the message payload from the attachments
        const messagePayload = {
            ...requestBody,
            attachments: undefined,
        };
        form.append('message', JSON.stringify(objKeysToSnakeCase(messagePayload)));
        // Add a separate form field for each attachment
        requestBody.attachments?.forEach((attachment, index) => {
            form.append(`file${index}`, attachment.content, {
                filename: attachment.filename,
                contentType: attachment.contentType,
            });
        });
        return form;
    }
}
// The maximum size of an attachment that can be sent using json
Messages.MAXIMUM_JSON_ATTACHMENT_SIZE = 3 * 1024 * 1024;
